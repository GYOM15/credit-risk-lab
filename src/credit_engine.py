# -*- coding: utf-8 -*-
"""credit_engine.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18J73DG3Y8qgVF1a29vQZJLUvMlvAArTN

## **SYSTÈME DECISIONNEL CRÉDIT END-TO-END**
"""
import numpy as np
import warnings
warnings.filterwarnings("ignore", category=FutureWarning, module='sklearn.pipeline')

def compute_credit_monthly_payment(capital, annual_rate, duration_months):

    monthly_rate = annual_rate / 12
    payment = (capital * monthly_rate) / (1 - (1 + monthly_rate) ** (-duration_months))

    return payment


def is_credit_affordable(monthly_payment, annual_income, threshold=0.33):

    monthly_income = annual_income / 12
    return monthly_payment <= monthly_income * threshold



def compute_max_authorized_capital(annual_income, annual_rate, duration_months, threshold=0.33):

    monthly_income = annual_income / 12
    max_payment = monthly_income * threshold

    monthly_rate = annual_rate / 12

    max_capital = max_payment * (1 - (1 + monthly_rate) ** (-duration_months)) / monthly_rate

    return max_capital



def get_dynamic_rate(proba_default):
    if proba_default < 0.05: return 0.03  # 3% pour les profils très sûrs
    if proba_default < 0.15: return 0.05  # 5%
    if proba_default < 0.25: return 0.08  # 8%
    return 0.12                          # 12% pour les profils risqués


def make_credit_decision(
    predicted_amount,
    annual_income,
    proba_default,
    duration_months
):

    #  Taux dynamique
    annual_rate = get_dynamic_rate(proba_default)

    #  Capacité max client
    max_capital = compute_max_authorized_capital(
        annual_income,
        annual_rate,
        duration_months
    )

    #  Pour prevenir des calclus unitils si capital trop faible
    if max_capital < 1000:
        return {
            "Decision": "Refusé",
            "Raison": "Capacité de remboursement insuffisante",
            "Niveau_Risque": round(proba_default, 3),
            "Taux_Propose": annual_rate
        }

    #  Comparaison ML vs capacité
    if predicted_amount <= max_capital:
        final_amount = predicted_amount
        decision_status = "Accepté"
        justification = "Montant conforme à la capacité d'endettement"
    else:
        final_amount = max_capital
        decision_status = "Ajusté"
        justification = "Montant ajusté selon la capacité maximale autorisée"

    #  Calcul de la mensualité finale
    final_payment = compute_credit_monthly_payment(
        final_amount,
        annual_rate,
        duration_months
    )

    # Ratio de l'endettement
    monthly_income = annual_income / 12
    debt_ratio = final_payment / monthly_income

    print("Salaire utilisé :", annual_income)

    return {
        "Decision": decision_status,
        "Montant_Modele": round(predicted_amount, 2),
        "Montant_Max_Autorise": round(max_capital, 2),
        "Montant_Final": round(final_amount, 2),
        "Mensualite": round(final_payment, 2),
        "Ratio_Endettement": round(debt_ratio, 3),
        "Niveau_Risque": round(proba_default, 3),
        "Taux_Propose": annual_rate,
        "Justification": justification
    }

"""## **FONCTION PRINCIPALE**"""

def decide(
    client_raw,
    client_ml,
    model_classif,
    model_reg,
    s_factor,
    duration_months=60
):
    """
    Système Expert End-to-End propre :
    - Séparation ML / Métier
    - Lisibilité complète
    """

    # =====================================================
    # EXTRACTION DES VARIABLES MÉTIER (EN PREMIER !)
    # =====================================================
    annual_income = client_raw["Salaire_Annuel"].values[0]

    # =====================================================
    # VÉRIFICATION SALAIRE MINIMUM
    # =====================================================
    SALAIRE_MINIMUM = 18000

    if annual_income < SALAIRE_MINIMUM:
        return {
            "Decision": "Refusé",
            "Raison": f"Salaire insuffisant ({annual_income:.0f}€ annuels)",
            "Montant_Final": 0,
            "Niveau_Risque": None,
            "Taux_Propose": None,
            "Justification": f"Le salaire minimum requis est {SALAIRE_MINIMUM}€/an"
        }

    # =====================================================
    # CLASSIFICATION
    # =====================================================
    proba_default = model_classif.predict_proba(client_ml)[:, 1][0]

    classification_decision = "Solvable" if proba_default <= 0.30 else "Risque Elevé"

    if proba_default > 0.30:
        return {
            "Decision": "Refusé",
            "Motif": "Score de risque trop élevé",
            "Probabilité_Défaut": round(proba_default, 4),
            "Verdict_Classification": classification_decision
        }

    # =====================================================
    # RÉGRESSION
    # =====================================================
    pred_log = model_reg.predict(client_ml)
    montant_modele = np.expm1(pred_log)[0] * s_factor

    # =====================================================
    # RÈGLES MÉTIER
    # =====================================================
    decision_business = make_credit_decision(
        predicted_amount=montant_modele,
        annual_income=annual_income,
        proba_default=proba_default,
        duration_months=duration_months
    )

    # =====================================================
    # OUTPUT COMPLET
    # =====================================================
    return decision_business



"""## **CLASSE SYSTÈME COMPLET DE DÉCISION DE CRÉDIT**"""

class CreditDecisionSystem:
    """
    Système complet de décision de crédit.
    Charge tous les modèles et expose une API simple.
    """
    
    def __init__(self, models_path):
        """
        Charge tous les modèles et métadonnées.
        
        Parameters
        ----------
        models_path : str
            Chemin vers le dossier contenant les modèles
        """
        import joblib
        import json
        
        # Charger le pipeline de preprocessing
        self.preprocessing = joblib.load(f'{models_path}/preprocessing_pipeline.joblib')
        
        # Charger le modèle de classification
        self.model_classif = joblib.load(f'{models_path}/modele_classification.joblib')
        
        # Charger le modèle de régression
        self.model_reg = joblib.load(f'{models_path}/model_ridge.joblib')
        
        # Charger les métadonnées de régression (pour le smearing factor)
        with open(f'{models_path}/model_ridge_metadata.json', 'r') as f:
            meta_reg = json.load(f)
            self.smearing_factor = meta_reg['transformation']['smearing_factor']
        
        print("Système de décision de crédit chargé avec succès")
        print(f"  - Pipeline de preprocessing : OK")
        print(f"  - Modèle de classification : OK")
        print(f"  - Modèle de régression : OK")
        print(f"  - Smearing factor : {self.smearing_factor:.6f}")
    
    def predict(self, client_raw, duration_months=60):
        """
        Prédiction complète pour un nouveau client.
        
        Parameters
        ----------
        client_raw : DataFrame
            Données brutes du client (avant preprocessing)
            Doit contenir : Age, Salaire_Annuel, Epargne_Totale, 
                           Score_Credit_Externe, Niveau_Etude, Ville
        duration_months : int
            Durée du prêt en mois (défaut : 60)
        
        Returns
        -------
        dict : Décision finale avec tous les détails
            {
                "Decision": "Accepté" | "Refusé" | "Ajusté",
                "Montant_Modele": float,
                "Montant_Max_Autorise": float,
                "Montant_Final": float,
                "Mensualite": float,
                "Ratio_Endettement": float,
                "Niveau_Risque": float,
                "Taux_Propose": float,
                "Justification": str
            }
        
        Examples
        --------
        >>> import pandas as pd
        >>> system = CreditDecisionSystem('./models/')
        >>> 
        >>> client = pd.DataFrame({
        ...     'Age': [35],
        ...     'Salaire_Annuel': [45000],
        ...     'Epargne_Totale': [10000],
        ...     'Score_Credit_Externe': [75],
        ...     'Niveau_Etude': ['Master'],
        ...     'Ville': ['Lyon']
        ... })
        >>> 
        >>> decision = system.predict(client)
        >>> print(decision)
        """
        # Preprocessing
        client_ml = self.preprocessing.transform(client_raw)
        
        # Décision complète
        return decide(
            client_raw=client_raw,
            client_ml=client_ml,
            model_classif=self.model_classif,
            model_reg=self.model_reg,
            s_factor=self.smearing_factor,
            duration_months=duration_months
        )
    
    def predict_batch(self, clients_raw, duration_months=60):
        """
        Prédiction pour plusieurs clients en batch.
        
        Parameters
        ----------
        clients_raw : DataFrame
            Plusieurs clients (plusieurs lignes)
        duration_months : int
            Durée du prêt en mois
        
        Returns
        -------
        list : Liste de décisions (une par client)
        """
        decisions = []
        
        for idx in range(len(clients_raw)):
            client = clients_raw.iloc[[idx]]
            decision = self.predict(client, duration_months)
            decisions.append(decision)
        
        return decisions